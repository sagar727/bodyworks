Index: app/src/main/java/com/example/bodyworks/waterReminder/WaterReminderActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.bodyworks.waterReminder\n\nimport android.app.AlarmManager\nimport android.app.AppOpsManager\nimport android.app.NotificationChannel\nimport android.app.NotificationManager\nimport android.app.PendingIntent\nimport android.content.Context\nimport android.content.Intent\nimport android.content.SharedPreferences\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Bundle\nimport android.provider.Settings\nimport android.widget.Button\nimport android.widget.TextView\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.app.NotificationCompat\nimport androidx.core.content.ContextCompat\nimport com.example.bodyworks.R\nimport com.example.bodyworks.databinding.ActivityWaterReminderBinding\nimport com.google.android.material.textfield.TextInputEditText\nimport com.google.android.material.timepicker.MaterialTimePicker\nimport com.google.android.material.timepicker.TimeFormat\nimport java.util.Calendar\n\n/**\n * Author: Ketul Chauhan\n * Date: Nov 7, 2023\n * */\nclass WaterReminderActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityWaterReminderBinding\n    private lateinit var txtViewStartTime: TextView\n    private lateinit var txtViewEndTime: TextView\n    private lateinit var btnStartTime: Button\n    private lateinit var btnEndTime: Button\n    private lateinit var timeIntervalInputTxt: TextInputEditText\n    private lateinit var btnStartReminder: Button\n    private var reminderStartHour: Int = 0\n    private var reminderStartMinute: Int = 0\n    private var reminderEndHour: Int = 0\n    private var reminderEndMinute: Int = 0\n\n    private lateinit var sharedPreferences: SharedPreferences\n\n    private val isReminderSetKey = \"isReminderSet\"\n    private val reminderStartHourKey = \"reminderStartHour\"\n    private val reminderStartMinuteKey = \"reminderStartMinute\"\n    private val reminderEndHourKey = \"reminderEndHour\"\n    private val reminderEndMinuteKey = \"reminderEndMinute\"\n    private val intervalKey = \"interval\"\n\n    companion object {\n        const val MY_PERMISSIONS_REQUEST_SEND_NOTIFICATION = 1001\n        lateinit var startAlarmPendingIntent: PendingIntent\n        lateinit var endAlarmPendingIntent: PendingIntent\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityWaterReminderBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        // Toolbar Code For Back button and title\n        val toolbar = binding.waterReminderToolbar\n        setSupportActionBar(toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        toolbar.setNavigationOnClickListener {\n            onBackPressed()\n        }\n\n        val startAlarmIntent = Intent(this, StartAlarmReceiver::class.java)\n        startAlarmPendingIntent =\n            PendingIntent.getBroadcast(this, 0, startAlarmIntent, PendingIntent.FLAG_IMMUTABLE)\n\n        val endAlarmIntent = Intent(this, EndAlarmReceiver::class.java)\n        endAlarmPendingIntent =\n            PendingIntent.getBroadcast(this, 0, endAlarmIntent, PendingIntent.FLAG_IMMUTABLE)\n\n        txtViewStartTime = binding.txtViewStartTime\n        txtViewEndTime = binding.txtViewEndTime\n        btnStartTime = binding.btnStartTime\n        btnEndTime = binding.btnEndTime\n        timeIntervalInputTxt = binding.timeIntervalInputTxt\n        btnStartReminder = binding.btnStartReminder\n\n        sharedPreferences = getSharedPreferences(\"WaterReminderPrefs\", Context.MODE_PRIVATE)\n        restorePreferences()\n\n        // Checking if reminder is set\n        updateButton()\n\n        btnStartTime.setOnClickListener {\n            openTimePicker(\"Select Reminder Start Time\")\n        }\n\n        btnEndTime.setOnClickListener {\n            openTimePicker(\"Select Reminder End Time\")\n        }\n\n        btnStartReminder.setOnClickListener {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n                if (ContextCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.VIBRATE\n                    ) != PackageManager.PERMISSION_GRANTED\n                ) {\n                    // Permission is not granted\n                    // Request the permission\n                    ActivityCompat.requestPermissions(\n                        this,\n                        arrayOf(android.Manifest.permission.VIBRATE),\n                        MY_PERMISSIONS_REQUEST_SEND_NOTIFICATION\n                    )\n                } else {\n                    // Permission has already been granted\n                    // Proceed with sending the notification\n                    if (!isReminderSet()) {\n                        savePreferences()\n                        scheduleNotification()\n                        updateButton()\n                    } else {\n                        cancelNotification()\n                        clearPreferences()\n                        updateButton()\n                    }\n                }\n            } else {\n                // For devices running on lower API levels, no explicit permission is required\n                if (!isReminderSet()) {\n                    savePreferences()\n                    scheduleNotification()\n                    updateButton()\n                } else {\n                    cancelNotification()\n                    clearPreferences()\n                    updateButton()\n                }\n            }\n\n            // Opening notification settings if notifications are off\n            if (!isNotificationEnabled()) {\n                openNotificationSettings()\n            }\n        }\n    }\n\n    private fun scheduleNotification() {\n        val manager: AlarmManager = getSystemService(Context.ALARM_SERVICE) as AlarmManager\n        val calendar = Calendar.getInstance()\n        val currentTime = Calendar.getInstance()\n\n        calendar.set(Calendar.HOUR_OF_DAY, reminderStartHour)\n        calendar.set(Calendar.MINUTE, reminderStartMinute)\n        calendar.set(Calendar.SECOND, 0)\n\n        if (calendar.before(currentTime)) {\n            calendar.add(Calendar.DATE, 1) // Set to next day if time has already passed today\n        }\n\n        val interval = timeIntervalInputTxt.text.toString().toLong() * 60 * 1000\n\n        manager.setRepeating(\n            AlarmManager.RTC_WAKEUP,\n            calendar.timeInMillis,\n            interval,\n            startAlarmPendingIntent\n        )\n\n        val endTimeCalendar = Calendar.getInstance()\n        endTimeCalendar.set(Calendar.HOUR_OF_DAY, reminderEndHour)\n        endTimeCalendar.set(Calendar.MINUTE, reminderEndMinute)\n        endTimeCalendar.set(Calendar.SECOND, 0)\n\n        if (endTimeCalendar.before(currentTime)) {\n            endTimeCalendar.add(Calendar.DATE, 1) // Set to next day if time has already passed today\n        }\n\n        manager.set(AlarmManager.RTC_WAKEUP, endTimeCalendar.timeInMillis, endAlarmPendingIntent)\n    }\n\n\n    private fun isNotificationEnabled(): Boolean {\n        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n\n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            notificationManager.areNotificationsEnabled()\n        } else {\n            val appOps = this.getSystemService(Context.APP_OPS_SERVICE) as AppOpsManager\n            val appOpsClass: Class<*> = appOps.javaClass\n            val checkOpNoThrowMethod = appOpsClass.getMethod(\n                \"checkOpNoThrow\", Integer.TYPE, Integer.TYPE, String::class.java\n            )\n            val opPostNotificationValue = appOpsClass.getDeclaredField(\"OP_POST_NOTIFICATION\")\n            val value = opPostNotificationValue.get(Int::class.java) as Int\n            checkOpNoThrowMethod.invoke(appOps, value, this.applicationInfo.uid, this.packageName) as Int == AppOpsManager.MODE_ALLOWED\n        }\n    }\n    private fun openNotificationSettings() {\n        val intent = Intent()\n        when {\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.O -> {\n                intent.action = Settings.ACTION_APP_NOTIFICATION_SETTINGS\n                intent.putExtra(Settings.EXTRA_APP_PACKAGE, packageName)\n            }\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP -> {\n                intent.action = \"android.settings.APP_NOTIFICATION_SETTINGS\"\n                intent.putExtra(\"app_package\", packageName)\n                intent.putExtra(\"app_uid\", applicationInfo.uid)\n            }\n            else -> {\n                intent.action = Settings.ACTION_APPLICATION_DETAILS_SETTINGS\n                intent.addCategory(Intent.CATEGORY_DEFAULT)\n                intent.data = Uri.parse(\"package:$packageName\")\n            }\n        }\n        startActivity(intent)\n    }\n\n    private fun openTimePicker(title: String) {\n        val picker =\n            MaterialTimePicker.Builder()\n                .setTimeFormat(TimeFormat.CLOCK_24H)\n                .setHour(7)\n                .setMinute(0)\n                .setTitleText(title)\n                .build()\n        picker.show(supportFragmentManager, \"Time Picker\")\n\n        picker.addOnPositiveButtonClickListener {\n            var hour: String = if (picker.hour <= 9) \"0${picker.hour}\" else \"${picker.hour}\"\n            var minute: String = if (picker.minute <= 9) \"0${picker.minute}\" else \"${picker.minute}\"\n\n            // Checking if the time picker is for the start or end time.\n            if (title === \"Select Reminder Start Time\") {\n                txtViewStartTime.text = \"$hour:$minute\"\n                reminderStartHour = picker.hour\n                reminderStartMinute = picker.minute\n            } else {\n                txtViewEndTime.text = \"$hour:$minute\"\n                reminderEndHour = picker.hour\n                reminderEndMinute = picker.minute\n            }\n        }\n    }\n\n    private fun isReminderSet(): Boolean {\n        return sharedPreferences.getBoolean(isReminderSetKey, false)\n    }\n\n    private fun savePreferences() {\n        val editor = sharedPreferences.edit()\n        editor.putBoolean(isReminderSetKey, true)\n        editor.putInt(reminderStartHourKey, reminderStartHour)\n        editor.putInt(reminderStartMinuteKey, reminderStartMinute)\n        editor.putInt(reminderEndHourKey, reminderEndHour)\n        editor.putInt(reminderEndMinuteKey, reminderEndMinute)\n        editor.putString(intervalKey, timeIntervalInputTxt.text.toString())\n        editor.apply()\n    }\n\n    private fun clearPreferences() {\n        val editor = sharedPreferences.edit()\n        editor.clear()\n        editor.apply()\n    }\n\n    private fun restorePreferences() {\n        if (isReminderSet()) {\n            reminderStartHour = sharedPreferences.getInt(reminderStartHourKey, 0)\n            reminderStartMinute = sharedPreferences.getInt(reminderStartMinuteKey, 0)\n            reminderEndHour = sharedPreferences.getInt(reminderEndHourKey, 0)\n            reminderEndMinute = sharedPreferences.getInt(reminderEndMinuteKey, 0)\n            timeIntervalInputTxt.setText(sharedPreferences.getString(intervalKey, \"\"))\n\n            if(reminderStartHour != 0){\n                var startHour: String = if (reminderStartHour <= 9) \"0$reminderEndHour\" else \"$reminderEndHour\"\n                var endHour: String = if (reminderEndHour <= 9) \"0$reminderEndHour\" else \"$reminderEndHour\"\n                var startMinute: String = if (reminderStartMinute <= 9) \"0$reminderStartMinute\" else \"$reminderStartMinute\"\n                var endMinute: String = if (reminderEndMinute <= 9) \"0$reminderEndMinute\" else \"$reminderEndMinute\"\n\n                txtViewStartTime.text = \"$startHour:$startMinute\"\n                txtViewEndTime.text = \"$endHour:$endMinute\"\n            }else {\n                txtViewStartTime.text = \"Start Time: \"\n                txtViewEndTime.text = \"End Time: \"\n            }\n        }\n    }\n\n    private fun updateButton() {\n        if (isReminderSet()) {\n            btnStartReminder.text = \"Stop Reminder\"\n        } else {\n            btnStartReminder.text = \"Start Reminder\"\n        }\n    }\n\n    private fun cancelNotification() {\n        val manager: AlarmManager = getSystemService(Context.ALARM_SERVICE) as AlarmManager\n        manager.cancel(startAlarmPendingIntent)\n        manager.cancel(endAlarmPendingIntent)\n    }\n}\n
===================================================================
diff --git a/app/src/main/java/com/example/bodyworks/waterReminder/WaterReminderActivity.kt b/app/src/main/java/com/example/bodyworks/waterReminder/WaterReminderActivity.kt
--- a/app/src/main/java/com/example/bodyworks/waterReminder/WaterReminderActivity.kt	
+++ b/app/src/main/java/com/example/bodyworks/waterReminder/WaterReminderActivity.kt	
@@ -161,7 +161,7 @@
         }
 
         val interval = timeIntervalInputTxt.text.toString().toLong() * 60 * 1000
-
+1
         manager.setRepeating(
             AlarmManager.RTC_WAKEUP,
             calendar.timeInMillis,
